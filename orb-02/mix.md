
# HAL CLI Repomix Output

**Generated on:** 2025-05-12T09:33:52.270394+00:00
**Source (relative path | url):** `.`

---

# File Summary

## Purpose
This file contains a packed representation of a repository's contents, generated by HAL CLI's Repomix plugin. It is designed to be easily consumable by AI systems for analysis, code review, or other automated processes.

## File Format
The content is organized as follows:
1. This summary section.
2. A directory structure representation with line references.
3. The contents of each file, preceded by its relative path.
4. Each file entry consists of:
   a. A header with the file path (`## File: path/to/file`)
   b. The full contents of the file in a fenced code block with language-specific syntax highlighting.

## Usage Guidelines
- Treat this file as read-only. Make changes in the original repository.
- Use the file paths provided to understand the context of each code snippet.
- Navigate to specific files using the line references in the directory structure.
- Be aware that this file might contain sensitive information if the original repository does.

## Notes
- Binary files, hidden files (starting with '.'), and files matching ignore patterns are excluded.
- File content reading errors are noted.

---

# Processed Files Summary

Total files: **3**

## File Statistics

**Total Files:** 3

**Total Size:** 47105 bytes

**Average File Size:** 15701 bytes

### Files by Extension

| Extension | Count | Percentage |
|-----------|-------|------------|
| "glsl" | 2 | "66.7%" |
| "html" | 1 | "33.3%" |


---

# Directory Structure with Line References
```
├── index.html (Line 347)
├── main.frag.glsl (Line 112)
└── main.vert.glsl (Line 934)

```

---

# Files (3)

## File: `main.frag.glsl`
```glsl
precision highp float;

// Varyings from vertex shader
varying float vNoise;       // Normalized LF displacement factor [0,1]
varying vec3 vNormal;       // LF-perturbed normal (view space)
varying vec3 vViewPosition; // Vector from fragment to camera in view space (fragment's position in view is -vViewPosition)
varying vec3 vAdvectedCoord; // LF Advected object-like coord (already scaled by uLfMasterScale)
varying float vPatternTime;   // Time for LF pattern evolution
varying float vGlobalTime;    // Global uTime from vertex shader for HF evolution
varying vec2 vUv; // Texture coordinates from vertex shader

// --- New Light Definition ---
#define MAX_LIGHTS 4 // Define a maximum number of lights

struct Light {
  vec3 color;
  float intensity;
  float diffuseContribution;
  float specularContribution;
  float specularShininess; // This will be a base shininess, can be modulated by texture
  vec3 position; // Position in view space
  float diffuseHfNormalAmount; // 0-1, blend factor for using HF normal in diffuse
  float specularHfNormalAmount; // 0-1, blend factor for using HF normal in specular
  bool enabled;
};
uniform Light uLights[MAX_LIGHTS];
uniform int uNumLights; // Actual number of active lights

// Global Ambient Intensity
uniform float uAmbientIntensity;

// Color Uniforms
uniform vec3 uColor1;
uniform vec3 uColor2;
uniform vec3 uColor3;
uniform vec3 uTroughColorMultiplier;
uniform float uTroughMin;
uniform float uTroughMax;
uniform float uTroughGamma;
uniform float uColorNoiseScale;
uniform float uColorNoiseTimeScale;

// HF Noise Uniforms
uniform bool uHfEnable;
uniform float uHfMasterScale;
uniform float uHfPatternTimeScale;
uniform float uHfOctaves;
uniform float uHfLacunarity;
uniform float uHfPersistence;
uniform float uHfNormalStrength;
uniform float uHfFlowScale;
uniform float uHfFlowStrength;
uniform float uHfFlowTimeScale;

// Shininess Texture Uniform
uniform sampler2D uShininessMap; // << NEW UNIFORM

// --- Simplex Noise Functions (random3_frag, simplex3d_frag) ---
vec3 random3_frag(vec3 c) {
  float j = 4096.0 * sin(dot(c, vec3(17.0, 59.4, 15.0)));
  vec3 r;
  r.z = fract(512.0 * j);
  j *= .125;
  r.x = fract(512.0 * j);
  j *= .125;
  r.y = fract(512.0 * j);
  return r - 0.5;
}
const float F3_FRAG = 0.3333333;
const float G3_FRAG = 0.1666667;
float simplex3d_frag(vec3 p) {
  vec3 s = floor(p + dot(p, vec3(F3_FRAG)));
  vec3 x = p - s + dot(s, vec3(G3_FRAG));
  vec3 e = step(vec3(0.0), x - x.yzx);
  vec3 i1 = e * (1.0 - e.zxy);
  vec3 i2 = 1.0 - e.zxy * (1.0 - e);
  vec3 x1 = x - i1 + G3_FRAG;
  vec3 x2 = x - i2 + 2.0 * G3_FRAG;
  vec3 x3 = x - 1.0 + 3.0 * G3_FRAG;
  vec4 w, d;
  w.x = dot(x, x);
  w.y = dot(x1, x1);
  w.z = dot(x2, x2);
  w.w = dot(x3, x3);
  w = max(0.6 - w, 0.0);
  d.x = dot(random3_frag(s), x);
  d.y = dot(random3_frag(s + i1), x1);
  d.z = dot(random3_frag(s + i2), x2);
  d.w = dot(random3_frag(s + 1.0), x3);
  w *= w;
  w *= w;
  d *= w;
  return dot(d, vec4(52.0));
}
// --- End of Simplex Noise ---

// --- HF Noise Specific Functions ---
vec3 get_hf_flow_vector(vec3 flow_coord_base, float flow_anim_time) {
  float flow_x = simplex3d_frag(vec3(flow_coord_base.x + 101.5, flow_coord_base.y + 63.2, flow_coord_base.z + 12.7 + flow_anim_time));
  float flow_y = simplex3d_frag(vec3(flow_coord_base.x - 47.8, flow_coord_base.y - 91.3, flow_coord_base.z - 39.5 + flow_anim_time));
  float flow_z = simplex3d_frag(vec3(flow_coord_base.x + 78.1, flow_coord_base.y - 123.4, flow_coord_base.z + 55.9 + flow_anim_time));
  return vec3(flow_x, flow_y, flow_z);
}

float fbm_simplex3d_hf_advected(
  vec3 p_advected_spatial_base,
  float pattern_time_val,
  float hf_octaves_float,
  float hf_lacunarity,
  float hf_persistence
) {
  float total = 0.0;
  float frequency = 1.0;
  float amplitude = 1.0;
  float maxValue = 0.0;
  int octaves = int(hf_octaves_float);
  for(int i = 0; i < octaves; i++) {
    if(i >= 8) // Max octaves safeguard
      break;
    vec3 current_p_spatial = p_advected_spatial_base * frequency;
    float current_pattern_time_component = pattern_time_val;
    float noise_sample = simplex3d_frag(vec3(current_p_spatial.xy, current_p_spatial.z + current_pattern_time_component));
    total += noise_sample * amplitude;
    maxValue += amplitude;
    amplitude *= hf_persistence;
    frequency *= hf_lacunarity;
  }
  if(maxValue == 0.0)
    return 0.0;
  return total / maxValue;
}
// --- End of HF Noise ---

void main() {
  // 1. Calculate Base Surface Color
  vec3 advectedCoordForColor = vAdvectedCoord * uColorNoiseScale;
  float colorNoiseInputTime = vPatternTime * uColorNoiseTimeScale;
  float colorNoiseValRaw = simplex3d_frag(vec3(advectedCoordForColor.xy, advectedCoordForColor.z + colorNoiseInputTime));
  float colorNoiseVal = colorNoiseValRaw * 0.5 + 0.5;
  vec3 baseSurfaceColor;
  float segment = colorNoiseVal * 2.0;
  if(segment < 1.0) {
    baseSurfaceColor = mix(uColor1, uColor2, segment);
  } else {
    baseSurfaceColor = mix(uColor2, uColor3, segment - 1.0);
  }
  float vNoiseMapped = pow(smoothstep(uTroughMin, uTroughMax, vNoise), uTroughGamma);
  vec3 troughEffectMultiplier = mix(uTroughColorMultiplier, vec3(1.0), vNoiseMapped);
  vec3 finalSurfaceColor = baseSurfaceColor * troughEffectMultiplier;

  // 2. Calculate Normals
  vec3 normal_lf_view = normalize(vNormal); // Base normal (LF perturbed) in view space
  vec3 normal_hf_view = normal_lf_view;     // Default to LF normal if HF is disabled or zero strength

  float vNoiseMappedInv = 1.0 - vNoiseMapped;
  float hf_noise_center;
  if(uHfEnable && uHfNormalStrength > 0.0 && uHfOctaves > 0.0) {
    vec3 hf_sample_coord_master = vAdvectedCoord * uHfMasterScale;
    vec3 hf_flow_sample_coord = hf_sample_coord_master * uHfFlowScale;
    float hf_flow_anim_time = vGlobalTime * uHfFlowTimeScale;
    vec3 hf_flow_vector = get_hf_flow_vector(hf_flow_sample_coord, hf_flow_anim_time);
    vec3 hf_advected_sample_coord = hf_sample_coord_master + hf_flow_vector * uHfFlowStrength;
    float hf_pattern_anim_time = vGlobalTime * uHfPatternTimeScale;

    float hf_eps = 0.01 / (uHfMasterScale > 0.0 ? uHfMasterScale : 1.0);
    if(uHfMasterScale == 0.0)
      hf_eps = 0.01;

    hf_noise_center = fbm_simplex3d_hf_advected(hf_advected_sample_coord, hf_pattern_anim_time, uHfOctaves, uHfLacunarity, uHfPersistence);
    float hf_noise_x_plus = fbm_simplex3d_hf_advected(hf_advected_sample_coord + vec3(hf_eps, 0.0, 0.0), hf_pattern_anim_time, uHfOctaves, uHfLacunarity, uHfPersistence);
    float hf_noise_y_plus = fbm_simplex3d_hf_advected(hf_advected_sample_coord + vec3(0.0, hf_eps, 0.0), hf_pattern_anim_time, uHfOctaves, uHfLacunarity, uHfPersistence);

    vec3 view_tangent = normalize(cross(normal_lf_view, vec3(0.0, 1.0, 0.01)));
    if(length(view_tangent) < 0.001) {
      view_tangent = normalize(cross(normal_lf_view, vec3(1.0, 0.0, 0.0)));
    }
    vec3 view_bitangent = normalize(cross(normal_lf_view, view_tangent));
    mat3 tbn = mat3(view_tangent, view_bitangent, normal_lf_view);

    float hf_noise_z_plus = fbm_simplex3d_hf_advected(hf_advected_sample_coord + vec3(0.0, 0.0, hf_eps), hf_pattern_anim_time, uHfOctaves, uHfLacunarity, uHfPersistence);
    vec3 hf_fbm_gradient_object_space_approx = vec3((hf_noise_x_plus - hf_noise_center) / hf_eps, (hf_noise_y_plus - hf_noise_center) / hf_eps, (hf_noise_z_plus - hf_noise_center) / hf_eps);

    vec3 normal_perturbation_tangent_space = normalize(vec3(hf_fbm_gradient_object_space_approx.x * uHfNormalStrength, hf_fbm_gradient_object_space_approx.y * uHfNormalStrength, 1.0));
    normal_hf_view = normalize(tbn * normal_perturbation_tangent_space);
  }

  // 3. Apply Lighting
  vec3 V = normalize(vViewPosition);
  vec3 fragmentPosView = -vViewPosition;

  vec3 totalDiffuse = vec3(0.0);
  vec3 totalSpecular = vec3(0.0);

  // Get shininess value from texture
  float shininessFromMap = texture2D(uShininessMap, vAdvectedCoord.xy).r; // Assuming shininess is in the red channel

  for(int i = 0; i < MAX_LIGHTS; ++i) {
    if(i >= uNumLights || !uLights[i].enabled)
      continue;

    Light currentLight = uLights[i];
    vec3 L = normalize(currentLight.position - fragmentPosView);

    vec3 N_diffuse = mix(normal_lf_view, normal_hf_view, currentLight.diffuseHfNormalAmount);
    N_diffuse = normalize(N_diffuse);

    float NdotL_diffuse = max(dot(N_diffuse, L), 0.0);
    totalDiffuse += currentLight.color * NdotL_diffuse * currentLight.diffuseContribution * currentLight.intensity;

    vec3 N_specular = mix(normal_lf_view, normal_hf_view, currentLight.specularHfNormalAmount);
    N_specular = normalize(N_specular);

    vec3 H = normalize(L + V);
    float NdotH_specular = max(dot(N_specular, H), 0.0);

    // Modulate specularShininess with texture value. Adjust multiplier as needed (e.g. 256.0)
    float finalShininess = currentLight.specularShininess * shininessFromMap; // << MODIFIED
    if(finalShininess < 1.0)
      finalShininess = 1.0; // Ensure shininess is at least 1

    float specularFactor = pow(NdotH_specular, finalShininess); // << MODIFIED
    totalSpecular += currentLight.color * specularFactor * currentLight.specularContribution * currentLight.intensity * (finalShininess / 255.0);
  }

  vec3 ambientColor = uAmbientIntensity * finalSurfaceColor;
  vec3 litColor = ambientColor + (totalDiffuse * finalSurfaceColor) + totalSpecular;
  litColor = pow(litColor, vec3(1.0 / 2.2));
  // gl_FragColor = vec4(vec3(shininessFromMap), 1.0);
  gl_FragColor = vec4(litColor, 1.0);
}
```

## File: `index.html`
```html
<!DOCTYPE html>
<html>

<head>
  <title>Three.js Flow Noise Shader - Unified Lighting</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background-color: #222;
      font-family: 'Inter', Arial, sans-serif;
    }

    canvas {
      display: block;
    }

    #info {
      position: absolute;
      top: 10px;
      left: 10px;
      padding: 10px;
      background-color: rgba(0, 0, 0, 0.75);
      color: white;
      border-radius: 8px;
      z-index: 100;
      font-size: 12px;
      max-width: 300px;
    }

    .lil-gui {
      top: 10px;
      right: 10px;
      max-height: calc(100vh - 20px);
      /* Ensure GUI fits on screen */
      overflow-y: auto;
      border-radius: 8px;
      --widget-padding: 5px;
      /* Adjust padding for a slightly more compact look */
      --folder-indent: 10px;
      --font-size: 11px;
    }

    .lil-gui.root>.children>.lil-gui>.title {
      font-size: 13px;
      /* Slightly larger for main folder titles */
    }
  </style>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
</head>

<body>
  <div id="info">
    Flow Noise Displacement (LF) + Flow Noise Normals (HF)<br>
    Unified Lighting System. Drag to rotate. Scroll to zoom.
  </div>
  <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.164.1/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.164.1/examples/jsm/",
                "lil-gui": "https://cdn.jsdelivr.net/npm/lil-gui@0.19.1/dist/lil-gui.esm.js"
            }
        }
    </script>
  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import GUI from 'lil-gui';

    let scene, camera, renderer, sphere, controls;
    let animationStartTime;
    let gui;
    const SETTINGS_KEY = 'flowNoiseShaderSettings_v4';

    let fetchedDefaultSettings = {};
    let guiParams = {};

    const MAX_LIGHTS_IN_SHADER = 4;

    let mainVertexShader, mainFragmentShader;
    let shininessTexture; // << NEW VARIABLE FOR TEXTURE

    async function fetchExternalDefaultSettings()
    {
      try
      {
        const response = await fetch('default-settings.json');
        if (!response.ok)
        {
          throw new Error(`HTTP error! status: ${response.status} while fetching default-settings.json`);
        }
        fetchedDefaultSettings = await response.json();
        console.log("Default settings loaded from default-settings.json");
      } catch (e)
      {
        console.error("CRITICAL ERROR fetching default-settings.json. Application might not work as expected.", e);
        document.getElementById('info').innerHTML = `Error loading default settings from JSON: ${e.message}. Please check console. App may be unstable. Using minimal fallbacks.`;
        fetchedDefaultSettings = {
          vertexDisplacementScale: 0.1, animationSpeed: 1.0, autoRotate: true, autoRotateSpeed: 0.2,
          sceneBackgroundColor: 0x202025, cameraFov: 60, cameraPosition: { x: 0, y: 0.75, z: 3.0 },
          cameraMinDistance: 1.0, cameraMaxDistance: 15.0,
          lfMasterScale: 0.1, lfPatternTimeScale: 0.03, lfOctaves: 3, lfLacunarity: 2.0, lfPersistence: 0.5,
          lfNoiseContrastLower: 0.0, lfNoiseContrastUpper: 1.0, lfNormalStrength: 0.15,
          lfFlowScale: 0.5, lfFlowStrength: 1.0, lfFlowTimeScale: 0.05,
          lfEnablePeriodic: false, lfPeriodicLengthX: 10, lfPeriodicLengthY: 10, lfPeriodicLengthZ: 10,
          hfEnable: true, hfMasterScale: 5.0, hfPatternTimeScale: 0.1, hfOctaves: 3, hfLacunarity: 2.0, hfPersistence: 0.5,
          hfNormalStrength: 0.05, hfFlowScale: 3.0, hfFlowStrength: 0.5, hfFlowTimeScale: 0.08,
          color1: { r: 0.8, g: 0.2, b: 0.1 }, color2: { r: 0.1, g: 0.7, b: 0.3 }, color3: { r: 0.2, g: 0.3, b: 0.9 },
          troughColorMultiplier: { r: 0.5, g: 0.5, b: 0.5 },
          troughMin: 0.0, troughMax: 0.5, troughGamma: 1.0,
          colorNoiseScale: 0.5, colorNoiseTimeScale: 0.05,
          ambientIntensity: 0.1, numLights: 1,
          lights: [
            {
              name: "Default Light 1", enabled: true, color: { r: 1.0, g: 1.0, b: 1.0 }, intensity: 1.0,
              diffuseContribution: 1.0, specularContribution: 0.5, specularShininess: 32.0,
              position: { x: 5.0, y: 5.0, z: 5.0 }, diffuseHfNormalAmount: 1.0, specularHfNormalAmount: 1.0
            }
          ]
        };
      }
    }

    function loadSettings()
    {
      if (Object.keys(fetchedDefaultSettings).length === 0)
      {
        console.warn("Fetched default settings are empty at the start of loadSettings.");
      }

      const baseDefaults = JSON.parse(JSON.stringify(fetchedDefaultSettings));
      const savedSettingsFromStorage = localStorage.getItem(SETTINGS_KEY);

      if (savedSettingsFromStorage)
      {
        try
        {
          const parsedLocalStorageSettings = JSON.parse(savedSettingsFromStorage);
          guiParams = { ...baseDefaults, ...parsedLocalStorageSettings };
          const nestedObjectKeys = ['color1', 'color2', 'color3', 'troughColorMultiplier', 'cameraPosition'];
          for (const key of nestedObjectKeys)
          {
            if (baseDefaults[key] && typeof baseDefaults[key] === 'object')
            {
              guiParams[key] = { ...baseDefaults[key], ...(parsedLocalStorageSettings[key] || {}) };
            }
          }
          if (Array.isArray(parsedLocalStorageSettings.lights))
          {
            guiParams.lights = JSON.parse(JSON.stringify(parsedLocalStorageSettings.lights));
          } else if (!Array.isArray(guiParams.lights))
          {
            guiParams.lights = Array.isArray(baseDefaults.lights) ? JSON.parse(JSON.stringify(baseDefaults.lights)) : [];
          }
          console.log("Settings loaded from localStorage and merged with JSON defaults.");
        } catch (e)
        {
          console.error("Error parsing saved settings from localStorage. Using JSON defaults.", e);
          guiParams = JSON.parse(JSON.stringify(fetchedDefaultSettings));
        }
      } else
      {
        console.log("No saved settings found in localStorage. Using JSON defaults.");
        guiParams = JSON.parse(JSON.stringify(fetchedDefaultSettings));
      }

      if (typeof guiParams.numLights !== 'number' || guiParams.numLights < 0 || guiParams.numLights > MAX_LIGHTS_IN_SHADER)
      {
        console.warn(`guiParams.numLights ('${guiParams.numLights}') is invalid. Resetting based on defaults or to 0.`);
        if (typeof baseDefaults.numLights === 'number' && baseDefaults.numLights >= 0 && baseDefaults.numLights <= MAX_LIGHTS_IN_SHADER)
        {
          guiParams.numLights = baseDefaults.numLights;
        } else
        {
          guiParams.numLights = 0;
        }
      }

      if (!Array.isArray(guiParams.lights))
      {
        console.warn("guiParams.lights is not an array. Initializing as empty array.");
        guiParams.lights = [];
      }

      for (let i = 0; i < MAX_LIGHTS_IN_SHADER; i++)
      {
        if (!guiParams.lights[i] || typeof guiParams.lights[i] !== 'object')
        {
          const defaultLightConfig = (baseDefaults.lights && baseDefaults.lights[i]) ?
            JSON.parse(JSON.stringify(baseDefaults.lights[i])) :
            {
              name: `Light ${i + 1}`, enabled: false, color: { r: 0.5, g: 0.5, b: 0.5 }, intensity: 0.0,
              diffuseContribution: 0.0, specularContribution: 0.0, specularShininess: 32,
              position: { x: 0, y: 0, z: (i + 1) * 2.0 },
              diffuseHfNormalAmount: 1.0, specularHfNormalAmount: 1.0
            };
          guiParams.lights[i] = defaultLightConfig;
          if (!guiParams.lights[i].name) guiParams.lights[i].name = `Light ${i + 1}`;
        } else if (!guiParams.lights[i].name)
        {
          guiParams.lights[i].name = `Light ${i + 1} (User)`;
        }
      }
      if (guiParams.lights.length > MAX_LIGHTS_IN_SHADER)
      {
        guiParams.lights.length = MAX_LIGHTS_IN_SHADER;
      }
    }

    function saveSettings()
    {
      try
      {
        localStorage.setItem(SETTINGS_KEY, JSON.stringify(guiParams));
        console.log("Settings saved to localStorage.");
      } catch (e)
      {
        console.error("Error saving settings to localStorage.", e);
      }
    }

    async function fetchShader(url)
    {
      const response = await fetch(url);
      if (!response.ok)
      {
        throw new Error(`Failed to fetch shader: ${url} ${response.statusText}`);
      }
      return response.text();
    }

    // Function to load textures
    async function loadTextures()
    { // << NEW FUNCTION
      const textureLoader = new THREE.TextureLoader();
      try
      {
        shininessTexture = await textureLoader.loadAsync('./smoothness.jpg'); // << LOAD TEXTURE
        shininessTexture.wrapS = THREE.RepeatWrapping;
        shininessTexture.wrapT = THREE.RepeatWrapping;
        console.log("Shininess texture loaded successfully.");
      } catch (error)
      {
        console.error("Error loading shininess texture:", error);
        document.getElementById('info').innerHTML += `<br>Error loading shininess.jpg: ${error.message}. Specular shininess might not work as intended.`;
        // Optionally, provide a fallback plain white texture or handle the error in shader uniforms
        const canvas = document.createElement('canvas');
        canvas.width = 1;
        canvas.height = 1;
        const context = canvas.getContext('2d');
        context.fillStyle = 'white'; // Default to full shininess if texture fails
        context.fillRect(0, 0, 1, 1);
        shininessTexture = new THREE.CanvasTexture(canvas);

      }
    }


    async function loadShadersAndTextures() // << MODIFIED FUNCTION NAME
    {
      try
      {
        await loadTextures(); // << CALL TEXTURE LOADING
        [mainVertexShader, mainFragmentShader] = await Promise.all([
          fetchShader('main.vert.glsl'),
          fetchShader('main.frag.glsl')
        ]);
        initScene();
        animateScene();
      } catch (error)
      {
        console.error("Error loading shaders or textures:", error); // << MODIFIED ERROR
        document.getElementById('info').innerHTML = `Error loading shaders/textures: ${error.message}. Please check console.`;
        throw error;
      }
    }

    function initScene()
    {
      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(window.devicePixelRatio);
      document.body.appendChild(renderer.domElement);

      scene = new THREE.Scene();
      scene.background = new THREE.Color(guiParams.sceneBackgroundColor || 0x202025);

      camera = new THREE.PerspectiveCamera(guiParams.cameraFov || 60, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.set(guiParams.cameraPosition?.x || 0, guiParams.cameraPosition?.y || 0.75, guiParams.cameraPosition?.z || 3.0);

      controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.05;
      controls.minDistance = guiParams.cameraMinDistance || 1.0;
      controls.maxDistance = guiParams.cameraMaxDistance || 15.0;
      controls.autoRotate = guiParams.autoRotate !== undefined ? guiParams.autoRotate : true;
      controls.autoRotateSpeed = guiParams.autoRotateSpeed !== undefined ? guiParams.autoRotateSpeed : 0.2;


      if (!animationStartTime) animationStartTime = performance.now();

      const sphereGeometry = new THREE.SphereGeometry(1, 96, 96);
      // IMPORTANT: Ensure your geometry has UVs. SphereGeometry has them by default.
      // If using a custom geometry, make sure it has UV attributes.
      sphereGeometry.computeTangents();

      const lightsUniformValue = [];
      const numActiveLightsForShader = Math.min(
        guiParams.numLights,
        guiParams.lights.length,
        MAX_LIGHTS_IN_SHADER
      );

      for (let i = 0; i < MAX_LIGHTS_IN_SHADER; i++)
      {
        const lightData = guiParams.lights[i];
        lightsUniformValue.push({
          enabled: (i < numActiveLightsForShader) ? (lightData.enabled !== undefined ? lightData.enabled : false) : false,
          color: new THREE.Color().setRGB(lightData.color?.r ?? 0, lightData.color?.g ?? 0, lightData.color?.b ?? 0),
          intensity: lightData.intensity !== undefined ? lightData.intensity : 0,
          diffuseContribution: lightData.diffuseContribution !== undefined ? lightData.diffuseContribution : 1.0,
          specularContribution: lightData.specularContribution !== undefined ? lightData.specularContribution : 1.0,
          specularShininess: lightData.specularShininess !== undefined ? lightData.specularShininess : 32.0,
          position: new THREE.Vector3(lightData.position?.x ?? 0, lightData.position?.y ?? 0, lightData.position?.z ?? 5.0),
          diffuseHfNormalAmount: lightData.diffuseHfNormalAmount !== undefined ? lightData.diffuseHfNormalAmount : 1.0,
          specularHfNormalAmount: lightData.specularHfNormalAmount !== undefined ? lightData.specularHfNormalAmount : 1.0
        });
      }

      const mainUniforms = {
        uTime: { value: 0.0 },
        uVertexDisplacementScale: { value: guiParams.vertexDisplacementScale },
        uLfMasterScale: { value: guiParams.lfMasterScale },
        uLfPatternTimeScale: { value: guiParams.lfPatternTimeScale },
        uLfOctaves: { value: Math.floor(guiParams.lfOctaves) },
        uLfLacunarity: { value: guiParams.lfLacunarity },
        uLfPersistence: { value: guiParams.lfPersistence },
        uLfNoiseContrastLower: { value: guiParams.lfNoiseContrastLower },
        uLfNoiseContrastUpper: { value: guiParams.lfNoiseContrastUpper },
        uLfNormalStrength: { value: guiParams.lfNormalStrength },
        uLfFlowScale: { value: guiParams.lfFlowScale },
        uLfFlowStrength: { value: guiParams.lfFlowStrength },
        uLfFlowTimeScale: { value: guiParams.lfFlowTimeScale },
        uEnablePeriodicLf: { value: guiParams.lfEnablePeriodic },
        uPeriodicLengthLf: { value: new THREE.Vector3(guiParams.lfPeriodicLengthX, guiParams.lfPeriodicLengthY, guiParams.lfPeriodicLengthZ) },
        uHfEnable: { value: guiParams.hfEnable },
        uHfMasterScale: { value: guiParams.hfMasterScale },
        uHfPatternTimeScale: { value: guiParams.hfPatternTimeScale },
        uHfOctaves: { value: Math.floor(guiParams.hfOctaves) },
        uHfLacunarity: { value: guiParams.hfLacunarity },
        uHfPersistence: { value: guiParams.hfPersistence },
        uHfNormalStrength: { value: guiParams.hfNormalStrength },
        uHfFlowScale: { value: guiParams.hfFlowScale },
        uHfFlowStrength: { value: guiParams.hfFlowStrength },
        uHfFlowTimeScale: { value: guiParams.hfFlowTimeScale },
        uColor1: { value: new THREE.Color().setRGB(guiParams.color1.r, guiParams.color1.g, guiParams.color1.b) },
        uColor2: { value: new THREE.Color().setRGB(guiParams.color2.r, guiParams.color2.g, guiParams.color2.b) },
        uColor3: { value: new THREE.Color().setRGB(guiParams.color3.r, guiParams.color3.g, guiParams.color3.b) },
        uTroughColorMultiplier: { value: new THREE.Vector3(guiParams.troughColorMultiplier.r, guiParams.troughColorMultiplier.g, guiParams.troughColorMultiplier.b) },
        uTroughMin: { value: guiParams.troughMin },
        uTroughMax: { value: guiParams.troughMax },
        uTroughGamma: { value: guiParams.troughGamma },
        uColorNoiseScale: { value: guiParams.colorNoiseScale },
        uColorNoiseTimeScale: { value: guiParams.colorNoiseTimeScale },
        uAmbientIntensity: { value: guiParams.ambientIntensity !== undefined ? guiParams.ambientIntensity : 0.1 },
        uLights: { value: lightsUniformValue },
        uNumLights: { value: numActiveLightsForShader },
        uShininessMap: { value: shininessTexture } // << ADD TEXTURE TO UNIFORMS
      };

      const mainMaterial = new THREE.ShaderMaterial({
        vertexShader: mainVertexShader,
        fragmentShader: mainFragmentShader,
        uniforms: mainUniforms,
      });

      sphere = new THREE.Mesh(sphereGeometry, mainMaterial);
      scene.add(sphere);

      setupGUI();
      window.addEventListener('resize', onWindowResize);
    }

    function setupGUI()
    {
      gui = new GUI();
      gui.title("Shader Controls");

      const saveButton = { save: saveSettings };
      gui.add(saveButton, 'save').name('Save Settings');
      const resetButton = { reset: () => { localStorage.removeItem(SETTINGS_KEY); window.location.reload(); } };
      gui.add(resetButton, 'reset').name('Reset to Defaults');

      gui.add(guiParams, 'vertexDisplacementScale', -0.6, 0.6, 0.001).name('Vertex Disp. Scale')
        .onChange(v => { if (sphere) sphere.material.uniforms.uVertexDisplacementScale.value = v; saveSettings(); });
      gui.add(guiParams, 'animationSpeed', 0.0, 1.0, 0.0001).name('Global Anim Speed').onChange(saveSettings);

      const lfFolder = gui.addFolder('LF Noise (Displacement)');
      const lfBaseNoiseFolder = lfFolder.addFolder('Base Noise Properties');
      lfBaseNoiseFolder.add(guiParams, 'lfMasterScale', 0.001, 10.0, 0.01).name('Master Scale').onChange(v => { sphere.material.uniforms.uLfMasterScale.value = v; saveSettings(); });
      lfBaseNoiseFolder.add(guiParams, 'lfPatternTimeScale', 0.0, 0.5, 0.001).name('Pattern Evo Speed').onChange(v => { sphere.material.uniforms.uLfPatternTimeScale.value = v; saveSettings(); });
      lfBaseNoiseFolder.add(guiParams, 'lfOctaves', 1, 8, 1).name('Octaves').onChange(v => { sphere.material.uniforms.uLfOctaves.value = Math.floor(v); saveSettings(); });
      lfBaseNoiseFolder.add(guiParams, 'lfLacunarity', 1.5, 4.0, 0.01).name('Lacunarity').onChange(v => { sphere.material.uniforms.uLfLacunarity.value = v; saveSettings(); });
      lfBaseNoiseFolder.add(guiParams, 'lfPersistence', 0.1, 1.0, 0.01).name('Persistence').onChange(v => { sphere.material.uniforms.uLfPersistence.value = v; saveSettings(); });
      lfBaseNoiseFolder.add(guiParams, 'lfNoiseContrastLower', 0.0, 1.0, 0.01).name('Contrast Min').onChange(v => { sphere.material.uniforms.uLfNoiseContrastLower.value = v; saveSettings(); });
      lfBaseNoiseFolder.add(guiParams, 'lfNoiseContrastUpper', 0.0, 1.0, 0.01).name('Contrast Max').onChange(v => { sphere.material.uniforms.uLfNoiseContrastUpper.value = v; saveSettings(); });
      lfBaseNoiseFolder.add(guiParams, 'lfNormalStrength', 0.0, 1.0, 0.001).name('LF Normal Strength').onChange(v => { sphere.material.uniforms.uLfNormalStrength.value = v; saveSettings(); });

      const lfFlowFolder = lfFolder.addFolder('Flow Field (Advection)');
      lfFlowFolder.add(guiParams, 'lfFlowScale', 0.001, 1.0, 0.01).name('Flow Detail Scale').onChange(v => { sphere.material.uniforms.uLfFlowScale.value = v; saveSettings(); });
      lfFlowFolder.add(guiParams, 'lfFlowStrength', 0.0, 5.0, 0.01).name('Flow Strength').onChange(v => { sphere.material.uniforms.uLfFlowStrength.value = v; saveSettings(); });
      lfFlowFolder.add(guiParams, 'lfFlowTimeScale', 0.0, 0.5, 0.001).name('Flow Evo Speed').onChange(v => { sphere.material.uniforms.uLfFlowTimeScale.value = v; saveSettings(); });

      const colorFolder = gui.addFolder('Surface Colors');
      colorFolder.addColor(guiParams, 'color1').name('Color 1 (Peak/Base)').onChange(v => { sphere.material.uniforms.uColor1.value.setRGB(guiParams.color1.r, guiParams.color1.g, guiParams.color1.b); saveSettings(); });
      colorFolder.addColor(guiParams, 'color2').name('Color 2 (Mid)').onChange(v => { sphere.material.uniforms.uColor2.value.setRGB(guiParams.color2.r, guiParams.color2.g, guiParams.color2.b); saveSettings(); });
      colorFolder.addColor(guiParams, 'color3').name('Color 3 (Base/Trough)').onChange(v => { sphere.material.uniforms.uColor3.value.setRGB(guiParams.color3.r, guiParams.color3.g, guiParams.color3.b); saveSettings(); });
      colorFolder.addColor(guiParams, 'troughColorMultiplier').name('Trough Multiplier').onChange(v => { sphere.material.uniforms.uTroughColorMultiplier.value.set(guiParams.troughColorMultiplier.r, guiParams.troughColorMultiplier.g, guiParams.troughColorMultiplier.b); saveSettings(); });
      colorFolder.add(guiParams, 'troughMin', 0.0, 1.0, 0.001).name('Trough Min').onChange(v => { sphere.material.uniforms.uTroughMin.value = v; saveSettings(); });
      colorFolder.add(guiParams, 'troughMax', 0.0, 1.0, 0.001).name('Trough Max').onChange(v => { sphere.material.uniforms.uTroughMax.value = v; saveSettings(); });
      colorFolder.add(guiParams, 'troughGamma', 0.1, 10.0, 0.01).name('Trough Gamma').onChange(v => { sphere.material.uniforms.uTroughGamma.value = v; saveSettings(); });
      colorFolder.add(guiParams, 'colorNoiseScale', 0.0001, 2.0, 0.001).name('Color Noise Scale').onChange(v => { sphere.material.uniforms.uColorNoiseScale.value = v; saveSettings(); });
      colorFolder.add(guiParams, 'colorNoiseTimeScale', 0.0, 0.5, 0.001).name('Color Noise Evo Speed').onChange(v => { sphere.material.uniforms.uColorNoiseTimeScale.value = v; saveSettings(); });

      const hfFolder = gui.addFolder('HF Noise (Detail Normals)');
      hfFolder.add(guiParams, 'hfEnable').name('Enable HF Normals').onChange(v => { sphere.material.uniforms.uHfEnable.value = v; saveSettings(); });
      hfFolder.add(guiParams, 'hfMasterScale', 0.1, 20.0, 0.001).name('HF Master Scale').onChange(v => { sphere.material.uniforms.uHfMasterScale.value = v; saveSettings(); });
      hfFolder.add(guiParams, 'hfPatternTimeScale', 0.0, 1.0, 0.001).name('HF Pattern Evo Speed').onChange(v => { sphere.material.uniforms.uHfPatternTimeScale.value = v; saveSettings(); });
      hfFolder.add(guiParams, 'hfOctaves', 1, 8, 1).name('HF Octaves').onChange(v => { sphere.material.uniforms.uHfOctaves.value = Math.floor(v); saveSettings(); });
      hfFolder.add(guiParams, 'hfLacunarity', 1.5, 4.0, 0.01).name('HF Lacunarity').onChange(v => { sphere.material.uniforms.uHfLacunarity.value = v; saveSettings(); });
      hfFolder.add(guiParams, 'hfPersistence', 0.1, 1.0, 0.01).name('HF Persistence').onChange(v => { sphere.material.uniforms.uHfPersistence.value = v; saveSettings(); });
      hfFolder.add(guiParams, 'hfNormalStrength', 0.0, 1.0, 0.001).name('HF Normal Strength').onChange(v => { sphere.material.uniforms.uHfNormalStrength.value = v; saveSettings(); });

      const hfFlowFolder = hfFolder.addFolder('HF Flow Field');
      hfFlowFolder.add(guiParams, 'hfFlowScale', 0.1, 20.0, 0.1).name('HF Flow Detail Scale').onChange(v => { sphere.material.uniforms.uHfFlowScale.value = v; saveSettings(); });
      hfFlowFolder.add(guiParams, 'hfFlowStrength', 0.0, 10.0, 0.01).name('HF Flow Strength').onChange(v => { sphere.material.uniforms.uHfFlowStrength.value = v; saveSettings(); });
      hfFlowFolder.add(guiParams, 'hfFlowTimeScale', 0.0, 1.0, 0.001).name('HF Flow Evo Speed').onChange(v => { sphere.material.uniforms.uHfFlowTimeScale.value = v; saveSettings(); });

      const lightingFolder = gui.addFolder('Lighting System');
      lightingFolder.add(guiParams, 'ambientIntensity', 0.0, 10.0, 0.01).name('Ambient Intensity')
        .onChange(v => { if (sphere) sphere.material.uniforms.uAmbientIntensity.value = v; saveSettings(); });

      lightingFolder.add(guiParams, 'numLights', 0, MAX_LIGHTS_IN_SHADER, 1).name('Active Lights Count')
        .onChange(v =>
        {
          if (sphere)
          {
            const newNumActive = Math.min(v, MAX_LIGHTS_IN_SHADER);
            sphere.material.uniforms.uNumLights.value = newNumActive;
            for (let k = 0; k < MAX_LIGHTS_IN_SHADER; k++)
            {
              if (k < newNumActive)
              {
                sphere.material.uniforms.uLights.value[k].enabled = guiParams.lights[k].enabled;
              } else
              {
                sphere.material.uniforms.uLights.value[k].enabled = false;
              }
            }
          }
          saveSettings();
        });

      for (let i = 0; i < MAX_LIGHTS_IN_SHADER; i++)
      {
        const lightGuiParams = guiParams.lights[i];
        const lightUniformRef = sphere.material.uniforms.uLights.value[i];
        const lightFolder = lightingFolder.addFolder(lightGuiParams.name || `Light ${i + 1}`);
        lightFolder.add(lightGuiParams, 'enabled').name('Enabled (if active)')
          .onChange(v =>
          {
            lightGuiParams.enabled = v;
            if (i < sphere.material.uniforms.uNumLights.value)
            {
              lightUniformRef.enabled = v;
            }
            saveSettings();
          });
        lightFolder.addColor(lightGuiParams, 'color').name('Color')
          .onChange(() =>
          {
            lightUniformRef.color.setRGB(lightGuiParams.color.r, lightGuiParams.color.g, lightGuiParams.color.b);
            saveSettings();
          });
        lightFolder.add(lightGuiParams, 'intensity', 0.0, 30.0, 0.01).name('Intensity')
          .onChange(v => { lightUniformRef.intensity = v; saveSettings(); });

        const contributionsFolder = lightFolder.addFolder('Contributions & Shininess');
        contributionsFolder.add(lightGuiParams, 'diffuseContribution', 0.0, 1.0, 0.01).name('Diffuse')
          .onChange(v => { lightUniformRef.diffuseContribution = v; saveSettings(); });
        contributionsFolder.add(lightGuiParams, 'specularContribution', 0.0, 1.0, 0.01).name('Specular')
          .onChange(v => { lightUniformRef.specularContribution = v; saveSettings(); });
        contributionsFolder.add(lightGuiParams, 'specularShininess', 1.0, 512.0, 1.0).name('Shininess (Base)') // << UPDATED NAME
          .onChange(v => { lightUniformRef.specularShininess = v; saveSettings(); });

        const positionFolder = lightFolder.addFolder('Position (View Space)');
        positionFolder.add(lightGuiParams.position, 'x', -30, 30, 0.1).name('X')
          .onChange(v => { lightUniformRef.position.x = v; saveSettings(); });
        positionFolder.add(lightGuiParams.position, 'y', -30, 30, 0.1).name('Y')
          .onChange(v => { lightUniformRef.position.y = v; saveSettings(); });
        positionFolder.add(lightGuiParams.position, 'z', -30, 30, 0.1).name('Z')
          .onChange(v => { lightUniformRef.position.z = v; saveSettings(); });

        const hfNormalsFolder = lightFolder.addFolder('HF Normal Influence');
        hfNormalsFolder.add(lightGuiParams, 'diffuseHfNormalAmount', 0.0, 1.0, 0.01).name('Diffuse HF Amt')
          .onChange(v => { lightUniformRef.diffuseHfNormalAmount = v; saveSettings(); });
        hfNormalsFolder.add(lightGuiParams, 'specularHfNormalAmount', 0.0, 1.0, 0.01).name('Specular HF Amt')
          .onChange(v => { lightUniformRef.specularHfNormalAmount = v; saveSettings(); });

        if (i >= guiParams.numLights)
        {
          lightFolder.close();
        } else if (i > 0)
        {
          lightFolder.close();
        }
      }
      lightingFolder.open();


      const sceneFolder = gui.addFolder('Scene & Camera');
      sceneFolder.add(guiParams, 'autoRotate').name('Auto Rotate').onChange(v => { controls.autoRotate = v; saveSettings(); });
      sceneFolder.add(guiParams, 'autoRotateSpeed', 0.0, 2.0, 0.01).name('Rotate Speed').onChange(v => { controls.autoRotateSpeed = v; saveSettings(); });
      sceneFolder.open();

      gui.controllersRecursive().forEach(controller =>
      {
        if (controller.updateDisplay) controller.updateDisplay();
      });
    }

    function onWindowResize()
    {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function animateScene()
    {
      requestAnimationFrame(animateScene);
      const currentTime = performance.now();

      if (!animationStartTime && currentTime > 0)
      {
        animationStartTime = currentTime;
      }
      const elapsedTimeSeconds = (currentTime - animationStartTime) * 0.001;

      if (sphere && sphere.material && sphere.material.uniforms.uTime)
      {
        sphere.material.uniforms.uTime.value = elapsedTimeSeconds * (guiParams.animationSpeed !== undefined ? guiParams.animationSpeed : 1.0);
      }
      controls.update();
      renderer.render(scene, camera);
    }

    async function main()
    {
      try
      {
        await fetchExternalDefaultSettings();
        loadSettings();
        await loadShadersAndTextures(); // << MODIFIED FUNCTION CALL
      } catch (error)
      {
        console.error("Failed to initialize the application:", error);
        const infoElement = document.getElementById('info');
        if (infoElement)
        {
          infoElement.innerHTML = `Critical error during application initialization: ${error.message}. Please check the console.`;
        }
      }
    }

    main();

  </script>
</body>

</html>
```

## File: `main.vert.glsl`
```glsl
// Uniforms
uniform float uTime;
uniform float uVertexDisplacementScale;

// LF (Low Frequency) Noise parameters
uniform float uLfMasterScale;
uniform float uLfPatternTimeScale;
uniform float uLfOctaves;
uniform float uLfLacunarity;
uniform float uLfPersistence;
uniform float uLfNoiseContrastLower;
uniform float uLfNoiseContrastUpper;
uniform float uLfNormalStrength; // Strength for perturbing normals based on LF noise

// Flow Parameters for LF noise
uniform float uLfFlowScale;
uniform float uLfFlowStrength;
uniform float uLfFlowTimeScale;

uniform bool uEnablePeriodicLf;
uniform vec3 uPeriodicLengthLf;

// Varyings
varying float vNoise;
varying vec3 vNormal; // This will carry the new, perturbed normal
varying vec3 vViewPosition;
varying vec3 vWorldPosition; // For fragment shader calculations
varying vec3 vAdvectedCoord; // The coordinate used for FBM lookup, for color noise
varying float vPatternTime;   // The time used for FBM lookup, for color noise
varying float vGlobalTime;
varying float vThickness;
varying vec2 vUv; // << NEW: To pass UVs to the fragment shader

// --- Nikita Miropolskiy's Simplex Noise (3D) ---
vec3 random3(vec3 c) {
  float j = 4096.0 * sin(dot(c, vec3(17.0, 59.4, 15.0)));
  vec3 r;
  r.z = fract(512.0 * j);
  j *= .125;
  r.x = fract(512.0 * j);
  j *= .125;
  r.y = fract(512.0 * j);
  return r - 0.5;
}
const float F3 = 0.3333333;
const float G3 = 0.1666667;
float simplex3d(vec3 p) {
  vec3 s = floor(p + dot(p, vec3(F3)));
  vec3 x = p - s + dot(s, vec3(G3));
  vec3 e = step(vec3(0.0), x - x.yzx);
  vec3 i1 = e * (1.0 - e.zxy);
  vec3 i2 = 1.0 - e.zxy * (1.0 - e);
  vec3 x1 = x - i1 + G3;
  vec3 x2 = x - i2 + 2.0 * G3;
  vec3 x3 = x - 1.0 + 3.0 * G3;
  vec4 w, d;
  w.x = dot(x, x);
  w.y = dot(x1, x1);
  w.z = dot(x2, x2);
  w.w = dot(x3, x3);
  w = max(0.6 - w, 0.0);
  d.x = dot(random3(s), x);
  d.y = dot(random3(s + i1), x1);
  d.z = dot(random3(s + i2), x2);
  d.w = dot(random3(s + 1.0), x3);
  w *= w;
  w *= w;
  d *= w;
  return dot(d, vec4(52.0));
}
// --- End of Nikita Miropolskiy's Simplex Noise ---

vec3 get_flow_vector(vec3 flow_coord_base, float flow_anim_time) {
  float flow_x = simplex3d(vec3(flow_coord_base.x + 13.7, flow_coord_base.y + 27.3, flow_coord_base.z + 5.1 + flow_anim_time));
  float flow_y = simplex3d(vec3(flow_coord_base.x - 9.2, flow_coord_base.y - 18.4, flow_coord_base.z - 11.9 + flow_anim_time));
  float flow_z = simplex3d(vec3(flow_coord_base.x + 31.5, flow_coord_base.y - 42.6, flow_coord_base.z + 17.8 + flow_anim_time));
  return vec3(flow_x, flow_y, flow_z);
}

float simplex3d_evolving_periodic(vec3 p_spatial, float time_component, vec3 period) {
  vec3 p_fract_norm = p_spatial / period;
  vec3 Pi0 = floor(p_fract_norm);
  vec3 Pf0 = p_fract_norm - Pi0;
  vec3 u = Pf0 * Pf0 * Pf0 * (Pf0 * (Pf0 * 6.0 - 15.0) + 10.0);

  float n000 = simplex3d(vec3(Pf0.x * period.x, Pf0.y * period.y, Pf0.z * period.z + time_component));
  float n100 = simplex3d(vec3((Pf0.x - 1.0) * period.x, Pf0.y * period.y, Pf0.z * period.z + time_component));
  float n010 = simplex3d(vec3(Pf0.x * period.x, (Pf0.y - 1.0) * period.y, Pf0.z * period.z + time_component));
  float n110 = simplex3d(vec3((Pf0.x - 1.0) * period.x, (Pf0.y - 1.0) * period.y, Pf0.z * period.z + time_component));
  float n001 = simplex3d(vec3(Pf0.x * period.x, Pf0.y * period.y, (Pf0.z - 1.0) * period.z + time_component));
  float n101 = simplex3d(vec3((Pf0.x - 1.0) * period.x, Pf0.y * period.y, (Pf0.z - 1.0) * period.z + time_component));
  float n011 = simplex3d(vec3(Pf0.x * period.x, (Pf0.y - 1.0) * period.y, (Pf0.z - 1.0) * period.z + time_component));
  float n111 = simplex3d(vec3((Pf0.x - 1.0) * period.x, (Pf0.y - 1.0) * period.y, (Pf0.z - 1.0) * period.z + time_component));

  float nx00 = mix(n000, n100, u.x);
  float nx10 = mix(n010, n110, u.x);
  float nx01 = mix(n001, n101, u.x);
  float nx11 = mix(n011, n111, u.x);
  float nxy0 = mix(nx00, nx10, u.y);
  float nxy1 = mix(nx01, nx11, u.y);
  return mix(nxy0, nxy1, u.z);
}

float fbm_simplex3d_advected(vec3 p_advected_spatial_base, float pattern_time_val, int octaves, float lacunarity, float persistence, bool enablePeriodic, vec3 periodicLength) {
  float total = 0.0;
  float frequency = 1.0;
  float amplitude = 1.0;
  float maxValue = 0.0;

  for(int i = 0; i < octaves; i++) {
    float noise_sample;
    vec3 current_p_spatial = p_advected_spatial_base * frequency;
    float current_pattern_time_component = pattern_time_val;

    if(enablePeriodic && periodicLength.x > 0.0 && periodicLength.y > 0.0 && periodicLength.z > 0.0) {
      noise_sample = simplex3d_evolving_periodic(current_p_spatial, current_pattern_time_component, periodicLength);
    } else {
      noise_sample = simplex3d(vec3(current_p_spatial.xy, current_p_spatial.z + current_pattern_time_component));
    }

    total += noise_sample * amplitude;
    maxValue += amplitude;
    amplitude *= persistence;
    frequency *= lacunarity;
  }
  if(maxValue == 0.0)
    return 0.0;
  return total / maxValue;
}

void main() {
    // Pass UV coordinates to fragment shader
  vUv = uv; // << ASSIGN UVs

    // 1. Calculate Flow Field
  vec3 flow_sample_coord = position * uLfFlowScale;
  float flow_anim_time = uTime * uLfFlowTimeScale;
  vec3 flow_vector = get_flow_vector(flow_sample_coord, flow_anim_time);

    // 2. Prepare base coordinate for main FBM pattern
  vec3 p_local_spatial = position * uLfMasterScale;

    // 3. Advect the base coordinate
  vec3 advected_spatial_coord = p_local_spatial + flow_vector * uLfFlowStrength;

    // 4. Determine time for main FBM pattern evolution
  float pattern_anim_time = uTime * uLfPatternTimeScale;

    // PASS ADVECTION INFO TO FRAGMENT SHADER
  vAdvectedCoord = advected_spatial_coord;
  vPatternTime = pattern_anim_time;
  vGlobalTime = uTime; // Pass global time for HF evolution in frag

    // 5. Calculate FBM on advected coordinates for DISPLACEMENT
  int octaves = int(uLfOctaves);
  float noiseVal = 0.0; // This is the FBM output in approx [-1, 1] range

  if(octaves > 0) {
    noiseVal = fbm_simplex3d_advected(advected_spatial_coord, pattern_anim_time, octaves, uLfLacunarity, uLfPersistence, uEnablePeriodicLf, uPeriodicLengthLf);
  }

    // 6. Calculate Perturbed Normal for LF displacement
  vec3 final_normal = normal;
  if(uLfNormalStrength > 0.0 && octaves > 0) {
    float eps = 0.01;
    float noise_x_plus = fbm_simplex3d_advected(advected_spatial_coord + vec3(eps, 0.0, 0.0), pattern_anim_time, octaves, uLfLacunarity, uLfPersistence, uEnablePeriodicLf, uPeriodicLengthLf);
    float noise_x_minus = fbm_simplex3d_advected(advected_spatial_coord - vec3(eps, 0.0, 0.0), pattern_anim_time, octaves, uLfLacunarity, uLfPersistence, uEnablePeriodicLf, uPeriodicLengthLf);
    float noise_y_plus = fbm_simplex3d_advected(advected_spatial_coord + vec3(0.0, eps, 0.0), pattern_anim_time, octaves, uLfLacunarity, uLfPersistence, uEnablePeriodicLf, uPeriodicLengthLf);
    float noise_y_minus = fbm_simplex3d_advected(advected_spatial_coord - vec3(0.0, eps, 0.0), pattern_anim_time, octaves, uLfLacunarity, uLfPersistence, uEnablePeriodicLf, uPeriodicLengthLf);
    float noise_z_plus = fbm_simplex3d_advected(advected_spatial_coord + vec3(0.0, 0.0, eps), pattern_anim_time, octaves, uLfLacunarity, uLfPersistence, uEnablePeriodicLf, uPeriodicLengthLf);
    float noise_z_minus = fbm_simplex3d_advected(advected_spatial_coord - vec3(0.0, 0.0, eps), pattern_anim_time, octaves, uLfLacunarity, uLfPersistence, uEnablePeriodicLf, uPeriodicLengthLf);
    vec3 fbm_gradient = vec3((noise_x_plus - noise_x_minus) / (2.0 * eps), (noise_y_plus - noise_y_minus) / (2.0 * eps), (noise_z_plus - noise_z_minus) / (2.0 * eps));
    final_normal = normalize(normal - fbm_gradient * uLfNormalStrength);
  }

    // 7. Calculate final displaced position
  float actual_displacement = noiseVal * uVertexDisplacementScale;
  vec3 displacedPosition = position + normal * actual_displacement;

    // --- Output to Rasterizer & Fragment Shader ---
  gl_Position = projectionMatrix * modelViewMatrix * vec4(displacedPosition, 1.0);

    // World position of the displaced vertex
  vWorldPosition = (modelMatrix * vec4(displacedPosition, 1.0)).xyz;

  vNormal = normalize(normalMatrix * final_normal);
  vec4 mvPosition = modelViewMatrix * vec4(displacedPosition, 1.0);
  vViewPosition = -mvPosition.xyz;

  float noiseVal01 = noiseVal * 0.5 + 0.5;
  noiseVal01 = (noiseVal01 - uLfNoiseContrastLower) / max(uLfNoiseContrastUpper - uLfNoiseContrastLower, 0.00001);
  vNoise = clamp(noiseVal01, 0.0, 1.0);
  vThickness = vNoise;
}
```


---
End of Repomix Output
---
